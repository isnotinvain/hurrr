'''
==================================================================
hurrr by Alex Levenson

Custom collections
=================================================================
'''
import heapq
import lang
import twod

class PriorityQueue(object):
  '''
  A min heap that defers to heapq
  but also maintains a paralell set
  so that __contains__ is O(1)

  Be sure to call heapify() when you modify
  elements inside the heap
  '''
  def __init__(self, elements=None):
    if not elements:
      elements = []
    self.cet = set(elements)
    self.lyst = list(elements)
    if len(self.cet) != len(self.lyst):
      raise ValueError("Elements contains duplicates")
    heapq.heapify(self.lyst)

  def push(self, item):
    self.cet.add(item)
    heapq.heappush(self.lyst, item)

  def pop(self):
    ret = heapq.heappop(self.lyst)
    self.cet.remove(ret)
    return ret

  def heapify(self):
    '''
    IF YOU CHANGE AN ELEMENT IN THIS PQ IN A WAY THAT EFFECTS
    ITS __cmp__, YOU MUST CALL THIS METHOD
    IT'S O(N)
    '''
    heapq.heapify(self.lyst)

  def __len__(self):
    return len(self.cet)

  def __contains__(self, item):
    return item in self.cet

class TwoDIndex(object):
  '''
  A container for items indexed by their 2d position hash
  Provides fast access for lookup of values inside a bounding box

  You must create a TwoDIndex with a designated "quant" which describes the degree
  to which values will be quantized. Specifically, points will be quantized by:
  (int(x / self.quant) * self.quant, int(y / self.quant) * self.quant)
  and therefore all points that quantize to the same value will end up in the same bucket

  When searching for points, you can specify a boolean 'prune' which determines whether to
  remove points potentially outise of the search criteria. Setting prune to false will be faster
  but less accurate, and may cause points near your search criteria but actually outside it to be
  returned.

  Supports insertion and removal via:
  myIndex[pt] = value
  del myIndex[pt]

  and retrieval via (if prune omitted assumed to be True)
  myIndex[center:distance] -> getValuesInSquare
  myIndex[center:distance:prune] -> getValuesInSquare
  myIndex[pt:pt] -> getValuesInBox
  myIndex[pt:pt:prune] -> getValuesInBox
  '''
  def __init__(self, quant):
    self.quant = quant
    self.hash = {}
    self.points = {}

  def __quantize(self, scalar):
    '''
    floors to the nearest quant
    '''
    return int(scalar / self.quant) * self.quant

  def __getValsAtPoint(self, pt):
    '''
    returns the quantized pt and vals in that bucket
    (or None if there aren't any)
    '''
    x,y = pt
    quantized = (self.__quantize(x), self.__quantize(y))
    vals = None
    if quantized in self.hash:
      vals = self.hash[quantized]
    return quantized, vals

  def __getAndInitializeValsAtPoint(self, pt):
    '''
    returns a set of values at the bucket that pt quantizes to
    if there are none, an empty set is initialized and placed in hash
    (and returned)
    '''
    quantized, vals = self.__getValsAtPoint(pt)
    if vals == None:
      vals = set()
      self.hash[quantized] = vals
    return vals

  def getValuesInBox(self, pt1, pt2, prune=True):
    '''
    returns a list of all values located between pt1 and pt2
    if prune is set to False, then points in the edge boxes will NOT
    be checked to ensure they are within pt1 and pt2, which means points
    within 1 quant of the bounding box could be returned as well
    '''
    lower, upper = twod.normalizeRect(pt1, pt2)
    qlower = self.__quantize(lower[0]), self.__quantize(lower[1])
    qupper = self.__quantize(upper[0]), self.__quantize(upper[1])
    vals = []
    for x in xrange(qlower[0], qupper[0]+1, self.quant):
      for y in xrange(qlower[1], qupper[1]+1, self.quant):
        pt = (x,y)
        if pt in self.hash:
          hits = self.hash[pt]
          if prune:
            if x in (qlower[0], qupper[0]):
              hits = (v for v in hits if self.points[v][0] >= lower[0] and self.points[v][0] <= upper[0])
            if y in (qlower[1], qupper[1]):
              hits = (v for v in hits if self.points[v][1] >= lower[1] and self.points[v][1] <= upper[1])
          vals.extend(hits)
    return vals

  def getValuesInSquare(self, center, dist, prune=True):
    '''
    same as getValuesInBox, but pt1 and pt2 are generated by creating a square
    centered around center with sidlengths of 2*dist
    '''
    cx, cy = center
    return self.getValuesInBox((cx-dist, cy-dist), (cx+dist, cy+dist), prune)

  def add(self, pt, value):
    '''
    inserts value into the index at point pt
    if value is already in the index, it will be REMOVED first
    and then added
    same as myIndex[pt] = value
    '''
    self[pt] = value

  def remove(self, value):
    '''
    Removes value from the index (if it is present)
    same as del myIndex[value]
    '''
    del self[value]

  def __setitem__(self, pt, value):
    del self[value]
    vals = self.__getAndInitializeValsAtPoint(pt)
    vals.add(value)
    self.points[value] = pt

  def __delitem__(self, value):
    if value in self.points:
      pt = self.points[value]
      del self.points[value]
      qp, vals = self.__getValsAtPoint(pt)
      vals.remove(value)
      if len(vals) == 0:
        del self.hash[qp]

  def __getitem__(self, key):
    if isinstance(key, slice):
      lang.ensureIterable(key.start, "Can only be accessed via [center:distance], [center:distance:prune], [pt:pt], or [pt:pt:prune]")
      prune = key.stop
      if prune == None: prune = True
      if lang.isIterable(key.stop):
        return self.getValuesInBox(key.start, key.stop, prune)
      else:
        return self.getValuesInSquare(key.start, key.stop, prune)
    raise TypeError("Can only be accessed via [center:distance], [center:distance:prune], [pt:pt], or [pt:pt:prune]")
